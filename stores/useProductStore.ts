// stores/useProductStore.ts - MEMORY-OPTIMIZED Product Store
import { create } from 'zustand';
import { Platform } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { api, apiUtils } from '@/services/api';
import { fileSystemManager } from '@/services/fileSystemManager';
import { imageProcessor } from '@/services/imageProcessor';
import { memoryManager, CriticalOperationManager } from '@/services/memoryManager';
import i18n from '@/i18n';

// √úr√ºn fotoƒürafƒ± aray√ºz√º
export interface ProductPhoto {
  id: string;
  productId: string;
  originalUri: string;
  thumbnailUri: string;
  processedUri?: string; // ƒ∞≈ülenmi≈ü g√∂rselin URI'si (arka planƒ± kaldƒ±rƒ±lmƒ±≈ü vb.)
  status: 'raw' | 'processing' | 'processed'; // G√∂rselin durumu
  createdAt: string;
  modifiedAt: string;
  editorSettings?: any; // Edit√∂r ayarlarƒ± (d√∂nd√ºrme, filtreler vb.)
}

// √úr√ºn aray√ºz√º
export interface Product {
  id: string;
  name: string;
  photos: ProductPhoto[];
  createdAt: string;
  modifiedAt: string;
}

// √úr√ºn maƒüazasƒ± aray√ºz√º
interface ProductStore {
  products: Product[]; // T√ºm √ºr√ºnler
  error: string | null; // Hata mesajƒ±
  isOnline: boolean; // Aƒü baƒülantƒ± durumu
  currentLanguage: string; // Mevcut dil

  // Fonksiyon tanƒ±mlamalarƒ±
  loadProducts: () => Promise<void>;
  createProduct: (name: string) => Promise<Product>;
  deleteProduct: (productId: string) => Promise<void>;
  updateProductName: (productId: string, name: string) => Promise<void>;
  addMultiplePhotos: (productId: string, imageUris: string[]) => Promise<boolean>;
  deletePhoto: (productId: string, photoId: string) => Promise<void>;
  removeMultipleBackgrounds: (productId: string, photoIds: string[]) => Promise<boolean>;
  getProductById: (productId: string) => Product | undefined;
  updatePhotoSettings: (productId: string, photoId: string, settings: any) => void;
  removeSingleBackground: (productId: string, photoId: string) => Promise<boolean>;
  updatePhotoThumbnail: (productId: string, photoId: string, newThumbnailUri: string) => Promise<void>;
  revertToRawForBackgroundChange: (productId: string, photoId: string) => Promise<void>;
  checkNetworkStatus: () => Promise<void>;
  changeLanguage: (lang: string) => void;
  batchDeletePhotos: (productId: string, photoIds: string[]) => Promise<boolean>;
  getMemoryStatus: () => {
    usedMemory: number;
    availableMemory: number;
    isLowMemory: boolean;
    operationsInQueue: number;
    productCount: number;
    totalPhotos: number;
    recommendations: {
      shouldCleanupOldDrafts: boolean;
      shouldOptimizeThumbnails: boolean;
      shouldReduceOperations: boolean;
    };
  };
  cleanupOldData: () => Promise<void>;
  emergencyRecovery: () => Promise<void>;
  getPerformanceStats: () => {
    platform: string;
    memory: ReturnType<ProductStore['getMemoryStatus']>;
    data: {
      products: number;
      photos: number;
      rawPhotos: number;
      processedPhotos: number;
    };
    criticalOperations: any; // CriticalOperationManager'dan gelen istatistikler
    lastUpdate: string;
  };
}

const STORAGE_KEY = 'studyo_products';

export const useProductStore = create<ProductStore>((set, get) => ({
  products: [],
  error: null,
  isOnline: true,
  currentLanguage: i18n.language || 'tr',

  /**
   * ‚úÖ MEMORY-OPTIMIZED: Product Loading with File Validation
   * √úr√ºnleri AsyncStorage'dan y√ºkler ve dosya doƒürulamasƒ±nƒ± ger√ßekle≈ütirir.
   * Eksik veya ge√ßersiz dosyalarƒ± kurtarmaya √ßalƒ±≈üƒ±r.
   * @returns Promise<void>
   * @throws Y√ºkleme veya doƒürulama sƒ±rasƒ±nda hata olu≈üursa.
   */
  loadProducts: async () => {
    return await memoryManager.addOperation(async () => {
      set({ error: null });

      try {
        const stored = await AsyncStorage.getItem(STORAGE_KEY);
        let products: Product[] = stored ? JSON.parse(stored) : [];

        // Platforma duyarlƒ± dosya doƒürulama ve kurtarma
        let hasChanges = false;

        for (const product of products) {
          for (const photo of product.photos) {
            // Orijinal dosyayƒ± doƒürula
            if (photo.originalUri) {
              const validatedUri = await imageProcessor.validateAndRecoverFile(photo.originalUri);
              if (!validatedUri) {
                console.warn(`‚ö†Ô∏è [${Platform.OS}] Missing original file for photo:`, photo.id);
                if (photo.processedUri) {
                  // ƒ∞≈ülenmi≈ü URI varsa orijinal URI olarak ayarla
                  photo.originalUri = photo.processedUri;
                  hasChanges = true;
                }
              }
            }

            // K√º√ß√ºk resmi doƒürula ve platform optimizasyonu ile yeniden olu≈ütur
            if (photo.thumbnailUri) {
              const validatedThumbnail = await imageProcessor.validateAndRecoverFile(photo.thumbnailUri);
              if (!validatedThumbnail) {
                console.warn(`‚ö†Ô∏è [${Platform.OS}] Missing thumbnail, recreating optimized:`, photo.id);
                try {
                  const sourceUri = photo.processedUri || photo.originalUri;
                  if (sourceUri) {
                    // Platforma optimize edilmi≈ü k√º√ß√ºk resim
                    const config = memoryManager.getThumbnailConfig();
                    const newThumbnail = await imageProcessor.createThumbnail(sourceUri, config.format);
                    photo.thumbnailUri = newThumbnail;
                    hasChanges = true;
                    console.log(`‚úÖ [${Platform.OS}] Optimized thumbnail recreated:`, photo.id);
                  }
                } catch (error) {
                  console.error(`‚ùå [${Platform.OS}] Failed to recreate thumbnail:`, photo.id, error);
                }
              }
            }

            // ƒ∞≈ülenmi≈ü dosyayƒ± doƒürula
            if (photo.processedUri) {
              const validatedProcessed = await imageProcessor.validateAndRecoverFile(photo.processedUri);
              if (!validatedProcessed) {
                console.warn(`‚ö†Ô∏è [${Platform.OS}] Missing processed file:`, photo.id);
                photo.status = 'raw'; // Durumu 'raw'a geri d√∂nd√ºr
                photo.processedUri = undefined; // ƒ∞≈ülenmi≈ü URI'yi kaldƒ±r
                hasChanges = true;
              }
            }
          }
        }

        // Deƒüi≈üiklik yapƒ±ldƒ±ysa depolamayƒ± g√ºncelle
        if (hasChanges) {
          await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(products));
          console.log(`üìÅ [${Platform.OS}] Product storage updated after file validation`);
        }

        set({ products });
      } catch (error: any) {
        const errorMessage = apiUtils.extractErrorMessage(error);
        set({ error: errorMessage });
        throw error;
      }
    }, {
      priority: 'high',
      memoryEstimate: Platform.OS === 'ios' ? 10 : 15,
      timeout: 30000
    });
  },

  /**
   * Yeni bir √ºr√ºn olu≈üturur ve depolamaya kaydeder.
   * @param name √úr√ºn√ºn adƒ±.
   * @returns Olu≈üturulan √ºr√ºn nesnesi.
   * @throws Hata olu≈üursa.
   */
  createProduct: async (name: string): Promise<Product> => {
    try {
      const newProduct: Product = {
        id: `product_${Date.now()}`,
        name,
        photos: [],
        createdAt: new Date().toISOString(),
        modifiedAt: new Date().toISOString(),
      };

      await fileSystemManager.createProductDirectory(newProduct.id); // √úr√ºn i√ßin dizin olu≈ütur
      const updatedProducts = [...get().products, newProduct];
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts));
      set({ products: updatedProducts });
      return newProduct;
    } catch (error: any) {
      const errorMessage = apiUtils.extractErrorMessage(error);
      set({ error: errorMessage });
      throw error;
    }
  },

  /**
   * Bir √ºr√ºn√º ve ilgili t√ºm dosyalarƒ±nƒ± siler.
   * @param productId Silinecek √ºr√ºn√ºn kimliƒüi.
   * @returns Promise<void>
   * @throws Hata olu≈üursa.
   */
  deleteProduct: async (productId: string) => {
    try {
      await fileSystemManager.deleteProductDirectory(productId); // √úr√ºn dizinini sil
      const updatedProducts = get().products.filter(p => p.id !== productId);
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts));
      set({ products: updatedProducts });
    } catch (error: any) {
      const errorMessage = apiUtils.extractErrorMessage(error);
      set({ error: errorMessage });
      throw error;
    }
  },

  /**
   * Bir √ºr√ºn√ºn adƒ±nƒ± g√ºnceller.
   * @param productId G√ºncellenecek √ºr√ºn√ºn kimliƒüi.
   * @param name Yeni √ºr√ºn adƒ±.
   * @returns Promise<void>
   * @throws Hata olu≈üursa.
   */
  updateProductName: async (productId, name) => {
    try {
      const updatedProducts = get().products.map(p =>
        p.id === productId ? { ...p, name, modifiedAt: new Date().toISOString() } : p
      );
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts));
      set({ products: updatedProducts });
    } catch (error: any) {
      const errorMessage = apiUtils.extractErrorMessage(error);
      set({ error: errorMessage });
      throw error;
    }
  },

  /**
   * ‚úÖ √á√ñZ√úM 1: Sequential Photo Addition with Memory Management
   * Bir √ºr√ºne birden fazla fotoƒürafƒ± sƒ±ralƒ± olarak ekler, her fotoƒüraf i√ßin bellek y√∂netimi ve k√º√ß√ºk resim olu≈üturmayƒ± optimize eder.
   * @param productId Fotoƒüraflarƒ±n ekleneceƒüi √ºr√ºn√ºn kimliƒüi.
   * @param imageUris Eklenecek g√∂rsellerin URI'leri.
   * @returns ƒ∞≈ülemin ba≈üarƒ±lƒ± olup olmadƒ±ƒüƒ±nƒ± belirten bir boolean.
   */
  addMultiplePhotos: async (productId, imageUris) => {
    return await CriticalOperationManager.withLock('add-multiple-photos', async () => {
      try {
        const product = get().products.find(p => p.id === productId);
        if (!product) throw new Error(i18n.t('common.productNotFound'));

        console.log(`üì∏ [${Platform.OS}] Starting sequential photo addition:`, {
          count: imageUris.length,
          productId
        });

        const newPhotos: ProductPhoto[] = [];

        // ‚úÖ SIRALI ƒ∞≈ûLEM: Her seferinde bir fotoƒüraf
        for (let i = 0; i < imageUris.length; i++) {
          const uri = imageUris[i];

          console.log(`üì∏ [${Platform.OS}] Processing photo ${i + 1}/${imageUris.length}`);

          const photoId = `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const originalFilename = `original_${photoId}.jpg`;

          // Bellek y√∂netimi ile sƒ±ralƒ± i≈ülemler
          const originalUri = await memoryManager.addOperation(async () => {
            return await fileSystemManager.saveImage(productId, uri, originalFilename);
          }, {
            priority: 'normal',
            memoryEstimate: Platform.OS === 'ios' ? 8 : 12,
            timeout: 15000
          });

          // Platforma optimize edilmi≈ü k√º√ß√ºk resim olu≈üturma
          const thumbnailUri = await imageProcessor.createThumbnail(originalUri);

          console.log(`‚úÖ [${Platform.OS}] Photo ${i + 1} processed successfully:`, photoId);

          newPhotos.push({
            id: photoId,
            productId,
            originalUri,
            thumbnailUri,
            status: 'raw',
            createdAt: new Date().toISOString(),
            modifiedAt: new Date().toISOString(),
          });

          // ƒ∞≈ülemler arasƒ±nda platforma √∂zg√º gecikme
          if (i < imageUris.length - 1) {
            await new Promise(resolve => setTimeout(resolve, Platform.OS === 'ios' ? 500 : 200));
          }
        }

        const updatedProducts = get().products.map(p =>
          p.id === productId ? {
            ...p,
            photos: [...p.photos, ...newPhotos],
            modifiedAt: new Date().toISOString()
          } : p
        );

        await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts));
        set({ products: updatedProducts });

        console.log(`‚úÖ [${Platform.OS}] All photos added successfully:`, newPhotos.length);
        return true;

      } catch (error: any) {
        const errorMessage = apiUtils.extractErrorMessage(error);
        set({ error: errorMessage });
        console.error(`‚ùå [${Platform.OS}] Photo addition failed:`, error);
        return false;
      }
    });
  },

  /**
   * Belirli bir fotoƒürafƒ± ve ilgili t√ºm dosyalarƒ±nƒ± siler.
   * @param productId Fotoƒürafƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoId Silinecek fotoƒürafƒ±n kimliƒüi.
   * @returns Promise<void>
   * @throws Hata olu≈üursa.
   */
  deletePhoto: async (productId, photoId) => {
    try {
      const product = get().products.find(p => p.id === productId);
      const photo = product?.photos.find(p => p.id === photoId);

      if (photo) {
        await fileSystemManager.deleteImage(photo.originalUri);
        if (photo.processedUri) await fileSystemManager.deleteImage(photo.processedUri);
        await fileSystemManager.deleteImage(photo.thumbnailUri);
      }

      const updatedProducts = get().products.map(p =>
        p.id === productId ? {
          ...p,
          photos: p.photos.filter(ph => ph.id !== photoId),
          modifiedAt: new Date().toISOString()
        } : p
      );

      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts));
      set({ products: updatedProducts });
    } catch (error: any) {
      const errorMessage = apiUtils.extractErrorMessage(error);
      set({ error: errorMessage });
      throw error;
    }
  },

  /**
   * ‚úÖ √á√ñZ√úM 1: Sequential Background Removal with Memory Management
   * Birden fazla fotoƒürafƒ±n arka planƒ±nƒ± sƒ±ralƒ± olarak kaldƒ±rƒ±r, aƒü baƒülantƒ±sƒ±nƒ± kontrol eder ve bellek y√∂netimi uygular.
   * @param productId Fotoƒüraflarƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoIds Arka planƒ± kaldƒ±rƒ±lacak fotoƒüraflarƒ±n kimlikleri.
   * @returns ƒ∞≈ülemin ba≈üarƒ±lƒ± olup olmadƒ±ƒüƒ±nƒ± belirten bir boolean.
   */
  removeMultipleBackgrounds: async (productId, photoIds) => {
    return await CriticalOperationManager.withLock('remove-multiple-backgrounds', async () => {
      const isOnline = await apiUtils.checkNetworkConnection();
      if (!isOnline) {
        set({
          error: i18n.t('networkErrors.networkRequired'),
          isOnline: false
        });
        return false;
      }

      set({ error: null, isOnline: true });
      const originalProductsState = JSON.parse(JSON.stringify(get().products)); // Ba≈üarƒ±sƒ±zlƒ±k durumunda geri d√∂nd√ºrmek i√ßin

      try {
        const tempProducts = JSON.parse(JSON.stringify(get().products));
        const product = tempProducts.find(p => p.id === productId);
        if (!product) throw new Error(i18n.t('common.productNotFound'));

        const photosToProcess = product.photos.filter(p =>
          photoIds.includes(p.id) && p.status === 'raw'
        );

        if (photosToProcess.length === 0) {
          return true; // ƒ∞≈ülenecek fotoƒüraf yoksa ba≈üarƒ±lƒ± say
        }

        console.log(`üîÑ [${Platform.OS}] Starting sequential background removal:`, {
          count: photosToProcess.length,
          productId
        });

        // UI: ƒ∞≈üleme durumunu g√∂ster
        photosToProcess.forEach(p => { p.status = 'processing'; });
        set({ products: tempProducts });

        // API √ßaƒürƒ±sƒ± (dil parametresi ile)
        const currentLang = get().currentLanguage;
        const apiPayload = photosToProcess.map(p => ({
          filename: `${p.id}.jpg`,
          uri: p.originalUri
        }));

        const result = await api.removeMultipleBackgrounds(apiPayload, currentLang);

        // Sonu√ßlarƒ± sƒ±ralƒ± olarak i≈üle
        const finalProducts = JSON.parse(JSON.stringify(get().products));
        const targetProduct = finalProducts.find(p => p.id === productId);
        if (!targetProduct) throw new Error(i18n.t('common.productNotFoundAfterProcess'));

        let successCount = 0;

        // ‚úÖ SIRALI SONU√á ƒ∞≈ûLEME: Her seferinde bir sonu√ß
        for (const [id, base64Data] of Object.entries(result.success)) {
          const photoId = id.replace('.jpg', '');
          const photo = targetProduct.photos.find(p => p.id === photoId);

          if (photo) {
            console.log(`üîÑ [${Platform.OS}] Processing successful result for photo:`, photoId);

            // Bellek y√∂netimi ile sƒ±ralƒ± dosya i≈ülemleri
            await memoryManager.addOperation(async () => {
              const oldOriginalUri = photo.originalUri;
              const oldThumbnailUri = photo.thumbnailUri;
              const processedFilename = `processed_${photoId}.png`;

              photo.processedUri = await fileSystemManager.saveBase64Image(
                productId,
                base64Data,
                processedFilename
              );
              photo.originalUri = photo.processedUri; // Orijinal URI'yi i≈ülenmi≈ü URI olarak g√ºncelle

              // Platforma optimize edilmi≈ü k√º√ß√ºk resim
              const config = memoryManager.getThumbnailConfig();
              photo.thumbnailUri = await imageProcessor.createThumbnail(photo.processedUri, config.format);

              photo.status = 'processed'; // Durumu 'processed' olarak ayarla
              photo.modifiedAt = new Date().toISOString();

              // Eski dosyalarƒ± temizle
              await fileSystemManager.deleteImage(oldOriginalUri);
              await fileSystemManager.deleteImage(oldThumbnailUri);

              console.log(`‚úÖ [${Platform.OS}] Photo processed successfully:`, photoId);
            }, {
              priority: 'normal',
              memoryEstimate: Platform.OS === 'ios' ? 15 : 25,
              timeout: 20000
            });

            successCount++;
          }
        }

        // Ba≈üarƒ±sƒ±z sonu√ßlarƒ± ele al
        for (const [id] of Object.entries(result.errors)) {
          const photoId = id.replace('.jpg', '');
          const photo = targetProduct.photos.find(p => p.id === photoId);
          if (photo) {
            photo.status = 'raw'; // Durumu 'raw'a geri d√∂nd√ºr
            console.warn(`‚ö†Ô∏è [${Platform.OS}] Photo processing failed:`, photoId);
          }
        }

        targetProduct.modifiedAt = new Date().toISOString();
        set({ products: finalProducts, isOnline: true });
        await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(finalProducts));

        console.log(`‚úÖ [${Platform.OS}] Background removal completed:`, {
          successful: successCount,
          total: photosToProcess.length
        });

        return successCount > 0;

      } catch (error: any) {
        console.error(`‚ùå [${Platform.OS}] removeMultipleBackgrounds failed:`, error);
        const errorMessage = apiUtils.extractErrorMessage(error);

        const isNetworkError = errorMessage.includes(i18n.t('common.networkError')) ||
          errorMessage.includes('network') ||
          errorMessage.includes('timeout');

        // Hata durumunda durumu orijinal haline geri d√∂nd√ºr
        set({
          error: errorMessage,
          products: originalProductsState,
          isOnline: !isNetworkError
        });

        await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(originalProductsState));
        return false;
      }
    });
  },

  /**
   * Belirli bir √ºr√ºn kimliƒüine g√∂re √ºr√ºn√º d√∂nd√ºr√ºr.
   * @param productId Aranacak √ºr√ºn√ºn kimliƒüi.
   * @returns √úr√ºn nesnesi veya bulunamazsa undefined.
   */
  getProductById: (productId) => get().products.find(p => p.id === productId),

  /**
   * Bir fotoƒürafƒ±n edit√∂r ayarlarƒ±nƒ± g√ºnceller ve arka plan durumuna g√∂re fotoƒürafƒ±n durumunu kontrol eder.
   * @param productId Fotoƒürafƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoId G√ºncellenecek fotoƒürafƒ±n kimliƒüi.
   * @param settings Yeni edit√∂r ayarlarƒ±.
   * @returns Promise<void>
   */
  updatePhotoSettings: (productId, photoId, settings) => {
    const updatedProducts = get().products.map(p => {
      if (p.id === productId) {
        return {
          ...p,
          photos: p.photos.map(photo => {
            if (photo.id === photoId) {
              // Durum g√ºncellemesi i√ßin arka plan kontrol√º
              const hasBackground = settings.backgroundId && settings.backgroundId !== 'none';
              const shouldBeProcessed = hasBackground || photo.processedUri; // Arka plan varsa veya zaten i≈ülenmi≈üse 'processed' olmalƒ±

              return {
                ...photo,
                editorSettings: settings,
                status: shouldBeProcessed ? 'processed' : photo.status, // Durumu g√ºncelle
                modifiedAt: new Date().toISOString()
              };
            }
            return photo;
          }),
          modifiedAt: new Date().toISOString()
        };
      }
      return p;
    });

    set({ products: updatedProducts });
    AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts)); // Depolamaya kaydet

    console.log(`üíæ [${Platform.OS}] Photo settings and status updated:`, {
      photoId,
      backgroundId: settings.backgroundId,
      hasBackground: settings.backgroundId !== 'none'
    });
  },

  /**
   * Belirli bir fotoƒürafƒ±n arka planƒ±nƒ± tek ba≈üƒ±na kaldƒ±rƒ±r.
   * @param productId Fotoƒürafƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoId Arka planƒ± kaldƒ±rƒ±lacak fotoƒürafƒ±n kimliƒüi.
   * @returns ƒ∞≈ülemin ba≈üarƒ±lƒ± olup olmadƒ±ƒüƒ±nƒ± belirten bir boolean.
   */
  removeSingleBackground: async (productId: string, photoId: string) => {
    return await CriticalOperationManager.withLock('remove-single-background', async () => {
      const isOnline = await apiUtils.checkNetworkConnection();
      if (!isOnline) {
        set({
          error: i18n.t('networkErrors.networkRequired'),
          isOnline: false
        });
        return false;
      }

      set({ error: null, isOnline: true });

      try {
        const product = get().products.find(p => p.id === productId);
        const photo = product?.photos.find(p => p.id === photoId);

        if (!product || !photo) {
          throw new Error(i18n.t('common.productNotFound'));
        }

        if (photo.status !== 'raw') {
          return true; // Zaten i≈ülenmi≈üse ba≈üarƒ±lƒ± say
        }

        console.log(`üîÑ [${Platform.OS}] Starting single background removal:`, photoId);

        // UI: ƒ∞≈üleme durumunu g√∂ster
        const tempProducts = get().products.map(p =>
          p.id === productId ? {
            ...p,
            photos: p.photos.map(ph =>
              ph.id === photoId ? { ...ph, status: 'processing' as const } : ph
            )
          } : p
        );
        set({ products: tempProducts });

        // API √ßaƒürƒ±sƒ±
        const currentLang = get().currentLanguage;
        const base64Data = await api.removeSingleBackground({
          filename: `${photoId}.jpg`,
          uri: photo.originalUri
        }, currentLang);

        console.log(`üì¶ [${Platform.OS}] API response received for photo:`, photoId);

        // ‚úÖ KRƒ∞Tƒ∞K: Sonucu doƒüru durum g√ºncellemesi ile i≈üle
        const processResult = await memoryManager.addOperation(async () => {
          const oldOriginalUri = photo.originalUri;
          const oldThumbnailUri = photo.thumbnailUri;
          const processedFilename = `processed_${photoId}.png`;

          const processedUri = await fileSystemManager.saveBase64Image(
            productId,
            base64Data,
            processedFilename
          );

          // Platforma optimize edilmi≈ü k√º√ß√ºk resim
          const config = memoryManager.getThumbnailConfig();
          const newThumbnailUri = await imageProcessor.createThumbnail(processedUri, config.format);

          console.log(`‚úÖ [${Platform.OS}] Files processed for photo:`, photoId);

          return {
            processedUri,
            newThumbnailUri,
            oldOriginalUri,
            oldThumbnailUri
          };
        }, {
          priority: 'high',
          memoryEstimate: Platform.OS === 'ios' ? 20 : 30,
          timeout: 25000
        });

        // ‚úÖ DURUM VE DOSYALARI G√úNCELLE
        const finalProducts = get().products.map(p =>
          p.id === productId ? {
            ...p,
            photos: p.photos.map(ph => {
              if (ph.id === photoId) {
                return {
                  ...ph,
                  originalUri: processResult.processedUri,
                  thumbnailUri: processResult.newThumbnailUri,
                  processedUri: processResult.processedUri, // ƒ∞≈ülenmi≈ü URI'yi kaydet
                  status: 'processed' as const,
                  modifiedAt: new Date().toISOString()
                };
              }
              return ph;
            }),
            modifiedAt: new Date().toISOString()
          } : p
        );

        // Durumu ve depolamayƒ± g√ºncelle
        set({ products: finalProducts, isOnline: true });
        await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(finalProducts));

        // Eski dosyalarƒ± temizle
        await fileSystemManager.deleteImage(processResult.oldOriginalUri);
        await fileSystemManager.deleteImage(processResult.oldThumbnailUri);

        console.log(`‚úÖ [${Platform.OS}] Single background removal completed with status fix:`, photoId);
        return true;

      } catch (error: any) {
        console.error(`‚ùå [${Platform.OS}] removeSingleBackground failed:`, error);
        const errorMessage = apiUtils.extractErrorMessage(error);

        const isNetworkError = errorMessage.includes(i18n.t('common.networkError')) ||
          errorMessage.includes('network') ||
          errorMessage.includes('timeout');

        // Hata durumunda fotoƒüraf durumunu 'raw'a geri d√∂nd√ºr
        const revertedProducts = get().products.map(p =>
          p.id === productId ? {
            ...p,
            photos: p.photos.map(ph =>
              ph.id === photoId ? { ...ph, status: 'raw' as const } : ph
            )
          } : p
        );

        set({
          error: errorMessage,
          products: revertedProducts,
          isOnline: !isNetworkError
        });

        return false;
      }
    });
  },

  /**
   * ‚úÖ √á√ñZ√úM 4: Memory-Safe Thumbnail Update with Strong Cache Busting
   * Belirli bir fotoƒürafƒ±n k√º√ß√ºk resmini bellek g√ºvenli bir ≈üekilde g√ºnceller ve g√º√ßl√º √∂nbellek bozan kullanƒ±r.
   * @param productId Fotoƒürafƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoId G√ºncellenecek fotoƒürafƒ±n kimliƒüi.
   * @param newThumbnailUri Yeni k√º√ß√ºk resmin URI'si.
   * @returns Promise<void>
   * @throws Hata olu≈üursa.
   */
  updatePhotoThumbnail: async (productId: string, photoId: string, newThumbnailUri: string) => {
    return await CriticalOperationManager.withLock('update-thumbnail', async () => {
      console.log(`üñºÔ∏è [${Platform.OS}] Starting memory-safe thumbnail update:`, { productId, photoId, newThumbnailUri });

      // Temizleme i√ßin √∂nceki k√º√ß√ºk resmi al
      const currentProducts = get().products;
      const currentProduct = currentProducts.find(p => p.id === productId);
      const currentPhoto = currentProduct?.photos.find(p => p.id === photoId);
      const oldThumbnailUri = currentPhoto?.thumbnailUri;

      // Platforma optimize edilmi≈ü g√º√ßl√º √∂nbellek bozan
      const cacheBustedUri = imageProcessor.createStrongCacheBustedUri(newThumbnailUri);

      const updatedProducts = currentProducts.map(p => {
        if (p.id === productId) {
          return {
            ...p,
            photos: p.photos.map(photo =>
              photo.id === photoId ? {
                ...photo,
                thumbnailUri: cacheBustedUri,
                modifiedAt: new Date().toISOString()
              } : photo
            ),
            modifiedAt: new Date().toISOString()
          };
        }
        return p;
      });

      // √ñnce durumu g√ºncelle (anƒ±nda UI geri bildirimi)
      set({ products: updatedProducts });

      try {
        // Bellek y√∂netimi ile AsyncStorage'a kaydet
        await memoryManager.addOperation(async () => {
          await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts));
        }, {
          priority: 'high',
          memoryEstimate: Platform.OS === 'ios' ? 5 : 8,
          timeout: 10000
        });

        console.log(`‚úÖ [${Platform.OS}] AsyncStorage updated successfully`);

        // Eski k√º√ß√ºk resmi temizle
        if (oldThumbnailUri && oldThumbnailUri !== newThumbnailUri) {
          try {
            const cleanOldUri = oldThumbnailUri.split('?')[0]; // √ñnbellek bozan parametreleri temizle
            await fileSystemManager.deleteImage(cleanOldUri);
            console.log(`üóëÔ∏è [${Platform.OS}] Old thumbnail deleted:`, cleanOldUri);
          } catch (deleteError) {
            console.warn(`‚ö†Ô∏è [${Platform.OS}] Old thumbnail deletion warning:`, deleteError);
          }
        }

        // Platforma √∂zg√º √∂nbellek ge√ßersizle≈ütirme
        setTimeout(async () => {
          try {
            await imageProcessor.clearImageCache();

            // Yeniden olu≈üturmayƒ± zorla
            const currentState = get();
            set({
              products: [...currentState.products] // Yeniden olu≈üturmak i√ßin y√ºzeysel kopyalama
            });

            console.log(`üîÑ [${Platform.OS}] Cache invalidation completed`);
          } catch (cacheError) {
            console.warn(`‚ö†Ô∏è [${Platform.OS}] Cache invalidation warning:`, cacheError);
          }
        }, Platform.OS === 'ios' ? 100 : 200);

      } catch (storageError: any) {
        console.error(`‚ùå [${Platform.OS}] AsyncStorage update failed:`, storageError);

        // Depolama hatasƒ± durumunda durumu geri d√∂nd√ºr
        set({ products: currentProducts });
        throw new Error(`${i18n.t('imageProcessing.thumbnailUpdateStorageFailed')}: ${storageError.message}`);
      }

      console.log(`‚úÖ [${Platform.OS}] Memory-safe thumbnail update completed:`, {
        productId,
        photoId,
        oldUri: oldThumbnailUri,
        newUri: cacheBustedUri
      });
    });
  },

  /**
   * ‚úÖ Background Change Optimization: Revert to Raw
   * Arka plan deƒüi≈üikliƒüi i√ßin i≈ülenmi≈ü bir fotoƒürafƒ± ham durumuna geri d√∂nd√ºr√ºr.
   * @param productId Fotoƒürafƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoId Geri d√∂nd√ºr√ºlecek fotoƒürafƒ±n kimliƒüi.
   * @returns Promise<void>
   */
  revertToRawForBackgroundChange: async (productId: string, photoId: string) => {
    return await CriticalOperationManager.withLock('revert-to-raw', async () => {
      console.log(`üîÑ [${Platform.OS}] Reverting processed photo to raw for background change:`, photoId);

      const currentProducts = get().products;
      const product = currentProducts.find(p => p.id === productId);
      const photo = product?.photos.find(p => p.id === photoId);

      if (!photo || photo.status !== 'processed') {
        console.log(`‚è≠Ô∏è [${Platform.OS}] Photo not found or not processed, skipping revert`);
        return;
      }

      // Ham g√∂rseli kullan (i≈ülenmi≈ü olan temiz √ºr√ºn fotoƒürafƒ±dƒ±r)
      let rawImageUri = photo.originalUri;

      // Eƒüer i≈ülenmi≈ü URI varsa, onu ham URI olarak kullan
      if (photo.processedUri) {
        rawImageUri = photo.processedUri;
      }

      // Platform optimizasyonu ile yeni ham k√º√ß√ºk resim olu≈ütur
      const config = memoryManager.getThumbnailConfig();
      const newThumbnailUri = await imageProcessor.createThumbnail(rawImageUri, config.format);
      console.log(`‚úÖ [${Platform.OS}] New raw thumbnail created for background change`);

      const updatedProducts = currentProducts.map(p => {
        if (p.id === productId) {
          return {
            ...p,
            photos: p.photos.map(ph => {
              if (ph.id === photoId) {
                return {
                  ...ph,
                  originalUri: rawImageUri, // Orijinal URI'yi ham g√∂rsel URI'si olarak ayarla
                  thumbnailUri: newThumbnailUri,
                  status: 'raw' as const, // Durumu 'raw' olarak ayarla
                  editorSettings: {
                    ...ph.editorSettings,
                    backgroundId: 'none' // Arka plan kimliƒüini 'none' olarak ayarla
                  },
                  modifiedAt: new Date().toISOString()
                };
              }
              return ph;
            }),
            modifiedAt: new Date().toISOString()
          };
        }
        return p;
      });

      set({ products: updatedProducts });
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProducts)); // Depolamaya kaydet

      console.log(`‚úÖ [${Platform.OS}] Photo reverted to raw for background change:`, photoId);
    });
  },

  /**
   * Aƒü baƒülantƒ± durumunu kontrol eder ve maƒüazanƒ±n durumunu g√ºnceller.
   * @returns Promise<void>
   */
  checkNetworkStatus: async () => {
    try {
      const isOnline = await apiUtils.checkNetworkConnection();
      set({ isOnline });

      if (!isOnline && get().error === null) {
        set({ error: i18n.t('networkErrors.noInternet') });
      } else if (isOnline && get().error?.includes(i18n.t('networkErrors.noInternet'))) {
        set({ error: null }); // Aƒü geri geldiƒüinde hata mesajƒ±nƒ± temizle
      }
    } catch (error) {
      set({ isOnline: false });
    }
  },

  /**
   * Uygulama dilini deƒüi≈ütirir.
   * @param lang Ayarlanacak dil kodu (√∂rneƒüin 'tr', 'en').
   */
  changeLanguage: (lang: string) => {
    set({ currentLanguage: lang });
  },

  /**
   * ‚úÖ Batch Operations Support
   * Birden fazla fotoƒürafƒ± toplu olarak siler, her silme i≈ülemi arasƒ±nda gecikme uygular.
   * @param productId Fotoƒüraflarƒ±n ait olduƒüu √ºr√ºn√ºn kimliƒüi.
   * @param photoIds Silinecek fotoƒüraflarƒ±n kimlikleri.
   * @returns ƒ∞≈ülemin ba≈üarƒ±lƒ± olup olmadƒ±ƒüƒ±nƒ± belirten bir boolean.
   */
  batchDeletePhotos: async (productId: string, photoIds: string[]) => {
    return await CriticalOperationManager.withLock('batch-delete', async () => {
      try {
        console.log(`üóëÔ∏è [${Platform.OS}] Starting batch photo deletion:`, photoIds.length);

        const product = get().products.find(p => p.id === productId);
        if (!product) throw new Error(i18n.t('common.productNotFound'));

        // Bellek g√ºvenliƒüi i√ßin sƒ±ralƒ± silme
        for (const photoId of photoIds) {
          await get().deletePhoto(productId, photoId); // Her fotoƒürafƒ± tek tek sil

          // Silmeler arasƒ±nda platforma √∂zg√º gecikme
          await new Promise(resolve =>
            setTimeout(resolve, Platform.OS === 'ios' ? 300 : 150)
          );
        }

        console.log(`‚úÖ [${Platform.OS}] Batch deletion completed`);
        return true;
      } catch (error: any) {
        console.error(`‚ùå [${Platform.OS}] Batch deletion failed:`, error);
        return false;
      }
    });
  },

  /**
   * ‚úÖ Memory Status and Cleanup
   * Mevcut bellek durumu istatistiklerini ve olasƒ± temizleme √∂nerilerini d√∂nd√ºr√ºr.
   * @returns Bellek durumu ve √∂nerileri i√ßeren bir nesne.
   */
  getMemoryStatus: () => {
    const memoryStatus = memoryManager.getMemoryStatus();
    const products = get().products;

    return {
      ...memoryStatus,
      productCount: products.length,
      totalPhotos: products.reduce((total, product) => total + product.photos.length, 0),
      recommendations: {
        shouldCleanupOldDrafts: products.length > 10, // √ñrneƒüin, 10'dan fazla taslak √ºr√ºn varsa temizle
        shouldOptimizeThumbnails: memoryStatus.isLowMemory,
        shouldReduceOperations: memoryStatus.operationsInQueue > 5,
      }
    };
  },

  /**
   * ‚úÖ Cleanup Old Data
   * Ge√ßici dosyalarƒ± ve √∂nbelleƒüi temizleyerek eski verileri temizler.
   * @returns Promise<void>
   */
  cleanupOldData: async () => {
    try {
      console.log(`üßπ [${Platform.OS}] Starting old data cleanup`);

      // Bellek y√∂neticisini temizle
      await memoryManager.cleanupMemory();

      // G√∂rsel i≈ülemci √∂nbelleƒüini temizle
      await imageProcessor.clearImageCache();

      console.log(`‚úÖ [${Platform.OS}] Old data cleanup completed`);
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${Platform.OS}] Cleanup warning:`, error);
    }
  },

  /**
   * ‚úÖ Emergency Recovery
   * Acil durumlarda uygulamayƒ± kurtarmak i√ßin kritik kurtarma i≈ülemleri ba≈ülatƒ±r.
   * @returns Promise<void>
   */
  emergencyRecovery: async () => {
    try {
      console.log(`üÜò [${Platform.OS}] Emergency recovery initiated`);

      // T√ºm kritik operasyonlarƒ± durdur
      CriticalOperationManager.clearAllLocks();

      // Acil bellek temizliƒüi
      await memoryManager.emergencyCleanup();
      await imageProcessor.emergencyMemoryRecovery();

      // √úr√ºnleri depolamadan yeniden y√ºkle
      await get().loadProducts();

      console.log(`‚úÖ [${Platform.OS}] Emergency recovery completed`);
    } catch (error) {
      console.error(`‚ùå [${Platform.OS}] Emergency recovery failed:`, error);
    }
  },

  /**
   * ‚úÖ Performance Monitoring
   * Uygulamanƒ±n performans istatistiklerini (bellek, veri, kritik operasyonlar) d√∂nd√ºr√ºr.
   * @returns Performans istatistiklerini i√ßeren bir nesne.
   */
  getPerformanceStats: () => {
    const memoryStats = get().getMemoryStatus();
    const products = get().products;

    return {
      platform: Platform.OS,
      memory: memoryStats,
      data: {
        products: products.length,
        photos: products.reduce((total, p) => total + p.photos.length, 0),
        rawPhotos: products.reduce((total, p) =>
          total + p.photos.filter(ph => ph.status === 'raw').length, 0
        ),
        processedPhotos: products.reduce((total, p) =>
          total + p.photos.filter(ph => ph.status === 'processed').length, 0
        ),
      },
      criticalOperations: CriticalOperationManager.getStats(),
      lastUpdate: new Date().toISOString(),
    };
  },
}));
